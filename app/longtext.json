{"longtext":"Wanna see something cool? React is getting native async support _and you can already try it out_ üòç\n\nThis will soon work anywhere:\n\n```javascript\nconst ShowData = async () => {\n  const res = await fetch(\"/data-source\")\n  const json = res.json()\n\n  return <p>{json.text}</p>\n}\n```\n\nNote the `async` React component, the `await` in its body, the complete lack of any loading states, effects, hooks, or libraries. It just works. You can use this component anywhere in your tree ‚Äì even in a component that isn't itself async!\n\nThis is part of React's [RFC: First class support for promises and async/await](https://github.com/reactjs/rfcs/pull/229). A next step from React Suspense, which I wrote about in [React 18 and the future of async data](https://swizec.com/blog/react-18-and-the-future-of-async-data/).\n\nThe goal is to make React Suspense easier to use. It worked!\n\n[![Parallel loading states in a NextJS 13 app](./img/Parallel-loading-states-in-a-NextJS-13-app1ej3c5.gif)](https://www.scholarstream.ai)\n\n## You can use async React in NextJS 13\n\nRight now the best way to try React's experimental support for promises is with [the beta side of NextJS 13](https://beta.nextjs.org/docs) ‚Äì the `/app` directory. I used it to build [ScholarStream.ai](https://ScholarStream.ai) and it feels weird, but works great.\n\nYou can [see my full code on GitHub](https://github.com/Swizec/ScholarStream.ai).\n\nThe `/app` directory embraces [Server Components](https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html) ‚Äì React components that render on the server and send plain HTML over the wire. No client-side JavaScript! Every re-render goes back to the server.\n\nNow I hear you thinking _\"But Swiz, that's slow as shit!? Didn't we invent single-page-apps because roundtrips to the server take too long??\"_\n\nYes, we did. Servers have come a long way since then.\n\nMy understanding is that Vercel, the company behind NextJS, uses extensive Serverless and Edge function shenanigans to run the tiniest possible server as close as possible to the user to render each component. Like Remix, they need a custom compiler built into NextJS to make this work smoothly.\n\n![Hybrid renders with NextJS, picture from docs](./img/Hybrid-renders-with-NextJS-picture-from-docs9fd18g.png)\n\nWhen a server component needs to render, a new function spins up _for just that render_. With the right config (and payment tier), that function runs on a CDN-like platform that aims for low latency. The function then returns _just that component's HTML_ and NextJS replaces the right section of your UI in the browser.\n\nI don't know how possible/easy it is to do this without Vercel. In theory NextJS is a standalone framework that toooootally works fine without Vercel.\n\nYes that means that even with server components there's plenty of client-side JavaScript left. But there's less :)\n\n## What async React looks like with beta NextJS\n\nAgain, full code on GitHub üëâ https://github.com/Swizec/ScholarStream.ai. See it in action üëâ [ScholarStream.ai](https://ScholarStream.ai)\n\nThe base case is to use NextJS 13's new opinionated `/app` structure:\n\n- `page.tsx` for the page\n- `layout.tsx` for the static layout\n- `loading.tsx` for the loading state\n\n![Loading state gif](./img/Loading-state-gif7add0f.gif)\n\n### page.tsx\n\n[Page components](https://beta.nextjs.org/docs/routing/pages-and-layouts#pages) are always server components. NextJS renders on the server, caches the result, and returns.\n\n```typescript\n// app/[route]/page.tsx\nexport default async function Home() {\n  return (\n    <main className={styles.main}>\n      <Pitch />\n\n      <h2>Read about:</h2>\n      <TopicsList />\n\n      {/* @ts-expect-error Server Component */}\n      <Feed topic=\"cs.AI\" count={5} isLast />\n    </main>\n  )\n}\n```\n\nYou need to tell TypeScript to expect an error when using `async` (server) components inside a JSX tree. It works, but types don't know about it yet. The NextJS team is working on getting that updated upstream.\n\n`<Feed>` in this case is the component that performs async data loading. NextJS seamlessly handles that no fuss.\n\n### layout.tsx\n\n[Layout components](https://beta.nextjs.org/docs/routing/pages-and-layouts#layouts) tell NextJS what to _always_ render around your page. When you nest subdirectories to make complex routes, their layouts also nest.\n\n```typescript\n// app/[route]/layout.tsx\nexport default function RootLayout({\n  // Layouts must accept a children prop.\n  // This will be populated with nested layouts or pages\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <Script\n        src=\"https://plausible.io/js/script.js\"\n        data-domain=\"scholarstream.ai\"\n      />\n      <body>\n        <nav className={styles.topNav}>\n          <Link href=\"/about\">About</Link>\n        </nav>\n        {children}\n        <div className={styles.footer}>\n          built with reckless abandon by <a href=\"https://swizec.com\">Swizec</a>\n          <br />\n          Thank you to arXiv for use of its open access interoperability.\n        </div>\n      </body>\n    </html>\n  )\n}\n```\n\n### loading.tsx\n\nThe [loading component](https://beta.nextjs.org/docs/routing/loading-ui) renders while waiting for the page component's promise to resolve.\n\n```typescript\n// app/[route]/loading.tsx\nexport default function PageLoading() {\n  return (\n    <main className={styles.main}>\n      <FeedLoader />\n    </main>\n  )\n}\n```\n\nAn interesting challenge here is that I couldn't find any open source React spinner components that worked. The animation wouldn't fire ü§®\n\n## Loading data\n\nLoading data is the typical example of a slow operation that requires promises. But [you can use the same techniques for anything](https://swizec.com/blog/you-can-use-react-query-for-slow-computation-not-just-api/).\n\nLike with React Query, the recommendation is to load data close to where it's used. Same component is best. You can think of it as declaring a data dependency in your component and letting React and NextJS handle the details.\n\nFor example, here's how I load an [arXiv feed](https://arxiv.org):\n\n```typescript\n// loads list of articles\n// renders in a loop\nexport const FeedInnards = async (props: FeedProps) => {\n  const { offset = 0, count = 10 } = props\n\n  let feed: arxiv.ArxivFeed\n  let papers: arxiv.ArxivFeedItem[]\n\n  try {\n    feed = await arxiv.getFeed(props.topic)\n    papers = feed.items.slice(offset, count)\n  } catch (e) {\n    console.error(e)\n\n    return (\n      <>\n        <p>Error loading feed. Try one of these topics instead:</p>\n        <TopicsList />\n      </>\n    )\n  }\n\n  return (\n    <>\n      {papers.map((paper) => (\n        // @ts-expect-error Server Component\n        <FeedItem paper={paper} key={paper.link} />\n      ))}\n    </>\n  )\n}\n```\n\nNotice the `await` in the body of that component, that's the shiny new toy! React/NextJS shows a loading state while this component's promise is pending. You don't have to deal with that üòç\n\nYou do have to write your own try/catch logic, however, because [error boundaries](https://reactjs.org/docs/error-boundaries.html) don't work with async components. Yet?\n\n### Extended fetch with caching\n\nThe data fetching behind my `<FeedInnards>` component looks like this:\n\n```typescript\nexport async function getFeed(category: string): Promise<ArxivFeed> {\n  const parser: Parser<Omit<ArxivFeed, \"items\">, ArxivFeedItem> = new Parser()\n  const feed = await fetch(\n    `http://export.arxiv.org/rss/${category}?version=1.0`,\n    {\n      next: { revalidate: TEN_HOURS },\n    }\n  ).then((r) => r.text())\n\n  try {\n    const parsed = await parser.parseString(feed)\n    return parsed\n  } catch (e) {\n    throw new Error(\"Could not parse feed\")\n  }\n}\n```\n\nFetch RSS feed from arXiv using a standard `fetch()` then parse with an RSS parser. Nothing crazy.\n\nBut notice the extra params in that fetch call:\n\n```typescript\nawait fetch(`http://export.arxiv.org/rss/${category}?version=1.0`, {\n  next: { revalidate: TEN_HOURS },\n})\n```\n\nNextJS [adds a custom param to fetch()](https://beta.nextjs.org/docs/api-reference/fetch) that lets you specify a caching behavior. You can enable/disable the cache and specify revalidation behavior.\n\nIn my case, the app fetches a fresh feed every 10 hours. Reload the page before then and you'll get a stable result with no loading indicators. Cache is stable across users and most visitors get a fast nearly static page.\n\n![Fast page on reload](./img/Fast-page-on-reloadhec276.gif)\n\nIt's unclear to me _where_ that cache lives. Is this something that works with NextJS or just with Vercel? ü§î\n\n### Cache without fetch for 3rd party libs\n\nWhen you don't control the underlying API call (like with a library), you can cache results using [the new `React.cache()` method](https://beta.nextjs.org/docs/data-fetching/caching#per-request-caching). Useful for any slow operation because it works on functions that return promises rather than hooking into `fetch()` itself.\n\nFor example when I'm [using OpenAI to create summaries](https://swizec.com/blog/building-apps-with-openai-and-chatgpt/):\n\n```typescript\nconst getSummary = cache(async (paper: arxiv.ArxivFeedItem) => {\n  const summary = await openai.getSummary(paper)\n  return summary\n})\n\nconst PaperSummary = async (props: { paper: arxiv.ArxivFeedItem }) => {\n  const summary = await getSummary(props.paper)\n\n  return <p>{summary.choices[0].text}</p>\n}\n```\n\nGoing hard on the idea that _\"You should load data close to where it's used\"_, I have a component that gets a `paper`, calls OpenAI to summarize, and renders a single paragraph.\n\nThe OpenAI call is wrapped in `cache()` to increase performance. For cost optimization I use additionally Redis caching on top. More on that another time :)\n\n## Custom Suspense boundaries\n\nPage level loading states are great, but you may want more fine-grained control. Or to load components in parallel with optimistic first-come rendering.\n\n![Parallel loading states with suspense boundaries](./img/Parallel-loading-states-with-suspense-boundaries5384bf.gif)\n\nYou do that with `<Suspense>` boundaries.\n\nFor example, when you know the summary portion of a `<FeedItem>` is slower than the rest:\n\n```typescript\nconst FeedItem = async (props: { paper: arxiv.ArxivFeedItem }) => {\n  const { paper } = props\n\n  // ...\n\n  return (\n    <div className={feedStyles.item}>\n      // ...\n      <Suspense fallback={<RingLoader color=\"blue\" loading />}>\n        {/* @ts-expect-error Server Component */}\n        <PaperSummary paper={paper} />\n      </Suspense>\n      <div>\n        Full paper at üëâ{\" \"}\n        <a href={paper.link} className={feedStyles.linkPaper}>\n          {paper.title.split(/(\\(|\\. \\()arXiv/)[0]}\n        </a>\n      </div>\n    </div>\n  )\n}\n```\n\nUsing the `<Suspense>` boundary is like telling React to _\"Render the `<FeedItem>` component, but show a `fallback` state while promises inside this part of the component tree are pending\"_.\n\nThe suspense boundary will capture every promise in its children. You don't have to coordinate anything.\n\nYou can pepper suspense boundaries wherever it makes sense for your app. Even the page level loading state is a suspense boundary under the hood.\n\n## Final thoughts\n\nI love it! Async React is going to simplify a lot of my code.\n\nBut I'm worried that this will be hard to implement outside NextJS and Vercel. We'll see.\n\nCheers,<br/>\n~Swizec\n\nPS: the [beta docs for NextJS 13](https://beta.nextjs.org/docs) are fantastic\n"}